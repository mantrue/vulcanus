package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"

	"github.com/pkg/errors"
)

// WSGenerator
// it will generate the restful.WebService
type WSGenerator struct {
	codeRepo struct {
		typesBuf bytes.Buffer
		wsBuf    bytes.Buffer
	} // hold generated bytes, which will write to .go file

	// web service path
	rootPath   string
	apiVersion string

	resourceTypes string // url subPath,  open-api tag, package name
	goTypes       string // golang type Name
}

// Print source code to buff
func (g *WSGenerator) WriteTypesF(format string, args ...interface{}) {
	fmt.Fprintf(&g.codeRepo.typesBuf, format, args...)
}

func (g *WSGenerator) WriteWSF(format string, args ...interface{}) {
	fmt.Fprintf(&g.codeRepo.wsBuf, format, args...)
}

// actor as the go fmt
func (g *WSGenerator) format() error {

	typesSrc, err := format.Source(g.codeRepo.typesBuf.Bytes())
	if err != nil {
		return errors.WithMessage(err, "format types source")
	}
	g.codeRepo.typesBuf = *bytes.NewBuffer(typesSrc)

	wsSrc, err := format.Source(g.codeRepo.wsBuf.Bytes())
	if err != nil {
		return errors.WithMessage(err, "format web-service source")
	}
	g.codeRepo.wsBuf = *bytes.NewBuffer(wsSrc)
	return nil
}

// Flush
// flush the buffer to file
func (g *WSGenerator) Flush(typesFile io.Writer, wsFile io.Writer) error {

	_, err := g.codeRepo.typesBuf.WriteTo(typesFile)
	if err != nil {
		return errors.WithMessage(err, "write types go file")
	}

	_, err = g.codeRepo.wsBuf.WriteTo(wsFile)
	if err != nil {
		return errors.WithMessage(err, "write web service go file")
	}

	return nil
}

// generate  types.go
// this file will use to fix by user
func (g *WSGenerator) generateTypes() {
	// the object communicate between with the server and client
}

// generate ws.go
